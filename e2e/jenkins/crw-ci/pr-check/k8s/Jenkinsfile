#!groovy

pipeline {
    agent { label params.jenkinsNodeLabel }

    options {
        timestamps()
        timeout(time: 30, unit: 'MINUTES')
        buildDiscarder(logRotator(artifactDaysToKeepStr: '',
                artifactNumToKeepStr: '', daysToKeepStr: '60', numToKeepStr: '100'))
    }

    environment {
        JENKINS_BUILD = "true"

        DEVFILE_URL = "${WORKSPACE}/e2e/files/happy-path/happy-path-workspace.yaml"
        SUCCESS_THRESHOLD = 5
    }

    parameters {
        choice(name: 'jenkinsNodeLabel',
                choices: ['codenvy-slave9',
                          'rhel7-16gb'],
                description: 'Label of Jenkins node which will be used to build the job')

        string(name: 'cheImage',
                defaultValue: 'eclipse/che-server:nightly',
                description: 'che-server image address')

        string(name: 'ghprbAuthorRepoGitUrl',
                defaultValue: 'https://github.com/eclipse/che.git',
                description: 'GitHub author repo git url')

        string(name: 'ghprbSourceBranch',
                defaultValue: 'master',
                description: 'GitHub source brunch')
    }

    stages {
        stage("Cleanup") {
            steps {
                script() {
                    sh "/usr/local/bin/minikube delete || true"
                }
            }
        }

        stage("Prepare to start Che on K8S") {
            failFast true

            parallel {
                stage("Download chectl") {
                    steps {
                        script {
                            // TO-DO use option "--install-path" https://github.com/eclipse/che/pull/14182
                            sh """
                               curl -sL  https://www.eclipse.org/che/chectl/ > install_chectl.sh
                               chmod +x install_chectl.sh
                               sudo PATH=$PATH ./install_chectl.sh --channel=next
                               sudo mv /usr/local/bin/chectl ${WORKSPACE}/chectl
                               sudo chmod +x ${WORKSPACE}/chectl
                            """
                        }
                    }
                }

                stage("Start Kubernetes") {
                    steps {
                        script {
                            sh """
                              /usr/local/bin/minikube start \\
                                --vm-driver=none \\
                                --cpus 4 \\
                                --memory 12288 \\
                                --logtostderr
                            
                              sudo chmod g+r -R /home/codenvy/.minikube
                              sudo chmod g+r -R /home/codenvy/.kube
                              sudo chmod g+r /var/lib/kubeadm.yaml
                            """
                        }
                    }
                }
            }
        }

        stage("Start Single Che") {
            steps {
                script {
                    sh """
                      ${WORKSPACE}/chectl server:start \\
                        --k8spodreadytimeout=180000 \\
                        -t=${WORKSPACE}/deploy/ \\
                        --listr-renderer=verbose \\
                        --cheimage=${params.cheImage}
                    """

                    // wait che-server to be available
                    sh """
                         CHE_URL=\$(kubectl get ingress che-ingress -n=che -o=jsonpath={'.spec.rules[0].host'})
                         
                         COUNTER=0;
                         SUCCESS_RATE_COUNTER=0;
                         while true; do
                          if [ \$COUNTER -gt 180 ]; then
                          echo "Unable to get stable route. Exiting"
                            exit 1
                          fi
                          
                          ((COUNTER+=1))
                          
                          
                          STATUS_CODE=\$(curl -sL -w "%{http_code}" -I \${CHE_URL} -o /dev/null; true) || true
                          
                          echo "Try \${COUNTER}. Status code: \${STATUS_CODE}"
                          if [ "\$STATUS_CODE" == "200" ]; then 
                            ((SUCCESS_RATE_COUNTER+=1))
                          fi
                          sleep 1;
                        
                          if [ \$SUCCESS_RATE_COUNTER == \$SUCCESS_THRESHOLD ]; then 
                            echo "Route is stable enough. Continuing running tests"
                            break
                          fi
                         done
                    """
                }
            }
        }

        stage("Create test workspace") {
            steps {
                script {
                    sh "${WORKSPACE}/chectl workspace:start --devfile=$DEVFILE_URL"
                }
            }
        }

        stage("Run E2E Happy path tests") {
            steps {
                script {
                    // TO-DO (#14171) switch to eclipse/che-e2e image
//                    sh """
//                         CHE_HOST=\$(kubectl get ingress che-ingress -n=che -o=jsonpath={'.spec.rules[0].host'})
//                         CHE_URL=http://\${CHE_HOST}
//                         docker run --shm-size=256m --net=host --ipc=host \\
//                           -e TS_SELENIUM_HEADLESS='true' \\
//                           -e TS_SELENIUM_DEFAULT_TIMEOUT=300000 \\
//                           -e TS_SELENIUM_LOAD_PAGE_TIMEOUT=240000 \\
//                           -e TS_SELENIUM_WORKSPACE_STATUS_POLLING=20000 \\
//                           -e TS_SELENIUM_BASE_URL=\${CHE_URL} \\
//                           -v ${WORKSPACE}/e2e:/root/local_tests:Z \\
//                           eclipse/che-e2e:nightly
//                     """

                    sh """
                        CHE_HOST=\$(kubectl get ingress che-ingress -n=che -o=jsonpath={'.spec.rules[0].host'})
                        CHE_URL=http://\${CHE_HOST}
                        docker run --net=host --ipc=host \\
                           -e TS_SELENIUM_HEADLESS='true' \\
                           -e TS_SELENIUM_DEFAULT_TIMEOUT=300000 \\
                           -e TS_SELENIUM_LOAD_PAGE_TIMEOUT=240000 \\
                           -e TS_SELENIUM_BASE_URL=\${CHE_URL} \\
                           -e TS_SELENIUM_WORKSPACE_STATUS_POLLING=20000 \\
                           -w /home/e2e \\
                           -v $WORKSPACE:/home:Z \\
                           cypress/browsers:node8.9.3-chrome73 bash -c "npm install &&  npm run test-happy-path"
                    """
                }
            }
        }
    }

    post {
        failure {
            script {
                echo "Create screencast from $WORKSPACE/e2e/report/executionScreencast files."
                sh """
                    command -v ffmpeg >/dev/null 2>&1 && if ls $WORKSPACE/e2e/report/executionScreencast/*.png 1> /dev/null 2>&1; then
                      cd $WORKSPACE/e2e/report/executionScreencast

                      # remove first screenshot which has lower resolution 800x600 and breaks screencast video
                      sudo rm -f 00100001* || true
                      
                      sudo ffmpeg -framerate 1 -pattern_type glob -i '*.png' -c:v libx264 -r 30 -pix_fmt yuv420p $WORKSPACE/e2e/report/screencast.mp4
                      cd $WORKSPACE/e2e/report/
                      sudo rm -rf $WORKSPACE/e2e/report/executionScreencast
                    fi
                """
            }
        }

        cleanup {
            archiveArtifacts allowEmptyArchive: true, artifacts: "e2e/report/**"

            script {
                sh """
                      kubectl get configmaps --namespace=che che -o yaml || true
                      
                      /usr/local/bin/minikube stop || true
                    
                      sudo umount \$(mount | grep "kubelet" | awk '{if(NR>0) print \$3}') || true
                      sudo rm -rf `sudo find /tmp -name 'hostpath-provisioner' 2>/dev/null` || true
                    
                      docker volume rm \$(docker volume ls -q -f dangling=true) || true
                      
                      docker rm -f \$(sudo docker ps --all | awk 'NR>0 {print \$1;}') || true
                 """

                sh "sudo rm -rf ${WORKSPACE}/e2e"
            }

            cleanWs notFailBuild: true, disableDeferredWipeout: true, deleteDirs: true
        }

    }

}
